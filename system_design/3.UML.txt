introduction to UML Diagrams
application idea-->friend-->1)paragraph  2)Diagram

UML Diagram-->
Definition:
UML (Unified Modeling Language) is a standardized visual language used to design, 
document, and communicate software architecture and system structure before implementation.

Key Points:
- Provides a common standard for visualizing system design across different platforms
- Uses symbols, shapes, and connectors to represent system components and relationships
- Helps developers, architects, and stakeholders understand complex systems
- Supports object-oriented design principles

Common UML Diagram Types:
1) Structural Diagrams - Show static aspects of a system(7)
   - Class Diagram
   - Object Diagram
   - Component Diagram
   - Deployment Diagram

2) Behavioral Diagrams - Show dynamic aspects and interactions(7)
   - Sequence Diagram
   - Use Case Diagram
   - State Machine Diagram
   - Activity Diagram

Benefits:
- Improves communication between team members
- Reduces development time and costs
- Facilitates better design decisions
- Creates reusable components

Class Diagram:-
Definition:
A Class Diagram is a structural diagram that shows the classes in a system, their attributes, 
methods, and the relationships between classes. It's the most commonly used UML diagram in 
object-oriented design.

Purpose:  
- Visualize the structure of classes and their interactions
- Define class properties (attributes) and behaviors (methods)
- Show relationships like inheritance, composition, and association
- Used extensively in Low-Level Design (LLD) to plan implementation

Key Components:

1) Class Box Structure:
   ┌─────────────────────┐
   │   ClassName         │ (Class Name)
   ├─────────────────────┤
   │ -attribute1: type   │ (Attributes/Properties)
   │ +attribute2: type   │
   ├─────────────────────┤
   │ +method1(): return  │ (Methods/Operations)
   │ -method2(param)     │
   └─────────────────────┘

also abstract class should be mentioned as abstract in-top of the Class-Structure
2) Access Modifiers:
   - Public (+): Accessible from anywhere
   - Private (-): Accessible only within the class
   - Protected (#): Accessible within class and subclasses
   - Package (~): Accessible within the same package

3) Relationships:

   a) Association (→): General relationship between classes
      Example: Student → Course (A student takes a course)
      
   b) Inheritance (△─): "is-a" relationship
      Example: Dog △─ Animal (Dog is an Animal)
      
   c) Composition (◆─): "part-of" relationship (strong ownership)
      Example: Car ◆─ Engine (Car contains Engine)
      
   d) Aggregation (◇─): "has-a" relationship (weak ownership)
      Example: Company ◇─ Employee (Company has Employees)

Simple Example: Bank System (Beginner LLD)
Classes Needed:
- Account: Stores account details
- Customer: Represents a customer
- Transaction: Records transactions

Class Diagram Representation:

Customer
├─ Attributes:
│  - customerId: int
│  - name: string
│  - email: string
├─ Methods:
│  + createAccount()
│  + closeAccount()
│  - validateEmail()

Account
├─ Attributes:
│  - accountNumber: string
│  - balance: float
│  - accountType: string
├─ Methods:
│  + deposit(amount)
│  + withdraw(amount)
│  + getBalance()
│  - updateBalance()

Transaction
├─ Attributes:
│  - transactionId: int
│  - amount: float
│  - date: DateTime
│  - type: string (credit/debit)
├─ Methods:
│  + recordTransaction()
│  + getTransactionDetails()

Relationships:
- Customer → Account (One customer can have multiple accounts)
- Account ◆─ Transaction (Account contains transactions)

Code Example (C++):

#include <string>
#include <iostream>
using namespace std;

class Customer {
private:
    int customerId;
    string name;
    string email;
    
    void validateEmail() { }
    
public:
    void createAccount() { }
    void closeAccount() { }
};

class Account {
private:
    string accountNumber;
    float balance;
    string accountType;
    
    void updateBalance() { }
    
public:
    void deposit(float amount) { }
    void withdraw(float amount) { }
    float getBalance() { return balance; }
};

class Transaction {
private:
    int transactionId;
    float amount;
    string date;
    string type;
    
public:
    void recordTransaction() { }
    string getTransactionDetails() { }
}

Best Practices for Class Diagram in LLD:
- Keep classes focused with single responsibility
- Use clear, descriptive names for classes and methods
- Show all important attributes and methods
- Use appropriate access modifiers
- Define relationships explicitly
- Avoid cluttering - include only necessary details
- Review and validate with stakeholders before implementation

Sequence diagram:-

Definition:
A Sequence Diagram is a behavioral diagram that shows how objects interact with each other over time. 
It illustrates the sequence of messages (method calls) exchanged between objects to complete a specific 
use case or scenario. It emphasizes the order and timing of interactions.

Purpose:
- Visualize the flow of control and data between objects
- Show the sequence of method calls and responses
- Document interactions for complex business processes
- Identify missing methods or incorrect message flows
- Used extensively in Low-Level Design (LLD) to plan object interactions
- Help understand system behavior during execution

Key Components:

1) Actors/Objects:
   - Represented as boxes at the top of the diagram
   - Can be external actors (users) or system objects (classes)
   Example: User, Customer, Account, Database

2) Lifelines:
   - Vertical dashed lines below each actor/object
   - Represent the existence of an object over time
   - Show the duration of object participation

3) Messages/Interactions:
   - Arrows showing communication between objects
   - Solid arrow (→): Synchronous call (waits for response)
   - Dashed arrow (→): Asynchronous call (doesn't wait)
   - Dashed return arrow (←): Return value

4) Activation Box:
   - Rectangle on the lifeline showing when an object is active
   - Indicates method execution period

5) Fragments:
   - alt: Alternative (if-else logic)
   - loop: Repetition
   - opt: Optional interaction
   - par: Parallel execution

Simple Example: Bank Withdrawal Process

Sequence Diagram for: Withdraw Money from ATM

Actors/Objects:
- User (External Actor)
- ATM (System)
- Account (System Object)
- Bank Database (System)

Flow:
1. User → ATM: Insert Card
2. ATM → Database: Verify Card
3. Database → ATM: Card Valid
4. ATM → User: Enter PIN
5. User → ATM: PIN
6. ATM → Database: Verify PIN
7. Database → ATM: PIN Correct
8. ATM → User: Enter Amount
9. User → ATM: Amount
10. ATM → Account: Withdraw(amount)
11. Account → Database: Update Balance
12. Database → Account: Success
13. Account → ATM: Withdrawal Successful
14. ATM → User: Dispense Cash

Sequence Diagram Representation:

   User          ATM         Account      Database
    |             |             |            |
    |--Insert---->|             |            |
    |             |--Verify---->|            |
    |             |             |--Check--->|
    |             |             |<--Valid---|
    |             |<--Valid-----|            |
    |<--PIN------|             |            |
    |--PIN------>|             |            |
    |             |--Verify---->|            |
    |             |             |--Check--->|
    |             |             |<--Valid---|
    |             |<--Valid-----|            |
    |<-Amount----|             |            |
    |--Amount--->|             |            |
    |             |--Withdraw->|            |
    |             |             |--Update->|
    |             |             |<--Ack----|
    |             |<--Success---|            |
    |<-Dispense--|             |            |

Code Example (C++) - Demonstrating Sequence:

#include <vector>
#include <iostream>
using namespace std;

class Account {
private:
    float balance;
    
public:
    bool withdraw(float amount) {
        if (amount <= balance) {
            balance -= amount;
            return true;
        }
        return false;
    }
};

class ATM {
private:
    void dispenseCash(float amount) {
        cout << "Dispensing: " << amount << endl;
    }
    
public:
    void withdrawMoney(float amount) {
        Account account;
        if (account.withdraw(amount)) {
            this->dispenseCash(amount);
        }
    }
};

Advanced Example: E-commerce Order Processing

Sequence:
1. Customer → ShoppingCart: Add Item
2. Customer → ShoppingCart: Checkout
3. ShoppingCart → Order: Create Order
4. Order → Payment: Process Payment
5. Payment → PaymentGateway: Authorize
6. PaymentGateway → Payment: Payment Authorized
7. Payment → Order: Payment Success
8. Order → Inventory: Reduce Stock
9. Inventory → Database: Update Stock
10. Database → Inventory: Confirmed
11. Inventory → Order: Stock Updated
12. Order → Notification: Send Confirmation
13. Notification → Email: Send Email
14. Email → Customer: Order Confirmed

Best Practices for Sequence Diagrams:

- Keep diagrams focused on a single scenario or use case
- Use clear, descriptive names for actors and messages
- Number the messages to show sequence clearly
- Use activation boxes to show object activity periods
- Avoid cluttering - include only essential interactions
- Use fragments (alt, loop) for conditional and repetitive logic
- Show return values only when necessary
- Review with stakeholders to ensure accuracy
- Maintain consistency with class diagrams
- Document assumptions and constraints

Comparison: Class vs Sequence Diagrams

Class Diagram:
- Shows static structure
- What classes exist and their relationships
- Focus on design-time view

Sequence Diagram:
- Shows dynamic behavior
- How objects interact at runtime
- Focus on execution-time view
